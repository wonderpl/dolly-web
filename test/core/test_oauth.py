import json, urllib, urlparse
import flask
from flask import request
from pyoauth2.provider import AuthorizationProvider, ResourceProvider

from test.base import RockPackTestCase


class session:
    user = 'this_user'
    user_id = 'this_user_id'


class DummyEngine(object):

    redirect_uri = '/this/is/a/redirect/' # provider by the client
    secret = 'sssssssssssshhhhhh' # generated by provider

    def __init__(self, client_id):
        self.client_id = client_id

    def find(self, client_id):
        return self


class DummyAuthStore(object):
    _dict = {}

    def _get_token(self, key):
        return self._dict.get(key, None)

    def _set_token(self, key, data):
        self._dict[key] = data
        print 'set key', key

    def _delete_token(self, key):
        try:
            del self._dict[key]
        except KeyError:
            print 'no key', key, 'present'
        else:
            print 'dropped key', key

    def set_auth_token(self, key, expires, data):
        self._set_token(key, (expires, data,))

    def get_auth_token(self, key):
        return self._get_token(key)[1]

    def delete_auth_token(self, key):
        self._delete_token(key)

    def set_access_refresh_pair(self, key, access_key, refresh_key):
        self._set_token(key, (access_key, refresh_key,))

    def delete_access_refresh_pair(self, key):
        self._delete_token(key)


class RockpackAuthorisationProvider(AuthorizationProvider):
    def __init__(self, client_engine, store):
        self.rockpack_client_engine = client_engine
        self.store = store

    def validate_client_id(self, client_id):
        return self.rockpack_client_engine.find(client_id)

    def validate_client_secret(self, client_id, client_secret):
        app = self.rockpack_client_engine.find(client_id)
        if app is not None and app.secret == client_secret:
            return True
        return False

    def validate_redirect_uri(self, client_id, redirect_uri):
        app = self.rockpack_client_engine.find(client_id)

        if app is not None and app.redirect_uri == redirect_uri.split('?')[0]:
            return True
        return False

    def validate_access(self):
        return session.user is not None

    def validate_scope(self, client_id, scope):
        return True if scope == '' else False

    def persist_authorization_code(self, client_id, code, scope):
        key = 'oauth2.authorization_code.%s:%s' % (client_id, code)
        data = {'client_id': client_id,
                'scope': scope,
                'user_id': session.user_id}

        self.store.set_auth_token(key, 60, json.dumps(data))

    def persist_token_information(self, client_id, scope, access_token,
            token_type, expires_in, refresh_token, data):

        # Set access token with proper expiration
        access_key = 'oauth2.access_token:%s' % access_token
        self.store.set_auth_token(access_key, expires_in, json.dumps(data))

        # Set refresh token with no expiration
        refresh_key = 'oauth2.refresh_token.%s:%s' % (client_id, refresh_token)
        self.store.set_auth_token(refresh_key, -1, json.dumps(data))

        # Associate tokens to user for easy token revocation per app user
        key = 'oauth2.client_user.%s:%s' % (client_id, data.get('user_id'))
        self.store.set_access_refresh_pair(key, access_key, refresh_key)

    def from_authorization_code(self, client_id, code, scope):
        key = 'oauth2.authorization_code.%s:%s' % (client_id, code)
        data = self.store.get_auth_token(key)
        if data is not None:
            data = json.loads(data)

            if (scope == '' or scope == data.get('scope')) and \
                    data.get('client_id') == client_id:
                return data
        return None

    def from_refresh_token(self, client_id, refresh_token, scope):
        key = 'oauth2.refresh_token.%s:%s' % (client_id, refresh_token)
        data = self.store.get_auth_token(key)
        if data is not None:
            data = json.loads(data)

            if (scope == '' or scope == data.get('scope')) and \
                    data.get('client_id') == client_id:
                return data
        return None

    def discard_authorization_code(self, client_id, code):
        key = 'oauth2.authorization_code.%s:%s' % (client_id, code)
        self.store.delete_auth_token(key)

    def discard_refresh_token(self, client_id, refresh_token):
        key = 'oauth2.refresh_token.%s:%s' % (client_id, refresh_token)
        self.store.delete_auth_token(key)

    def discard_client_user_tokens(self, client_id, user_id):
        key = 'oauth2.client_user.%s:%s' % (client_id, user_id)
        self.store.delete_access_refresh_pair(key)


class RockpackResourceProvider(ResourceProvider):

    def get_authorization_header(self):
        return request.header.get('Authorization', None)

    def validate_access_token(self, access_token, authorization):
        pass


class TestOauthProvider(RockPackTestCase):

    def setUp(self):
        super(TestOauthProvider, self).setUp()

        self.test_client_id = 'some_client_id'
        dummy_engine = DummyEngine(self.test_client_id)
        dummy_auth_store = DummyAuthStore()

        from rockpack.mainsite import app

        @app.route('/test/oauth2/auth', methods=('GET',))
        def auth_code():
            provider = RockpackAuthorisationProvider(dummy_engine, dummy_auth_store)

            response = provider.get_authorization_code_from_uri(request.url)

            flask_res = flask.make_response(response.text, response.status_code)
            for k, v, in response.headers.iteritems():
                flask_res.headers[k] = v
            return flask_res

        @app.route('/test/oauth2/token', methods=('POST',))
        def token():
            provider = RockpackAuthorisationProvider(dummy_engine, dummy_auth_store)

            data = {k: v for k, v in request.form.iteritems()}

            response = provider.get_token_from_post_data(data)

            flask_res = flask.make_response(response.text, response.status_code)
            for k, v in response.headers.iteritems():
                flask_res.headers[k] = v
            return flask_res

    def test_auth_flow(self):
        with self.app.test_client() as client:
            r = client.get('/test/oauth2/auth?{}'.format(
                    urllib.urlencode({'response_type': 'code',
                        'client_id': self.test_client_id,
                        'redirect_uri': DummyEngine.redirect_uri,
                        'rockpack_id': 'fv7j4uewhnr7rt34yklfyaiojkl'})))

            self.assertEquals(302, r.status_code, 'response status should be 302')
            redirect_data = dict(urlparse.parse_qsl(urlparse.urlparse(r.headers.get('Location')).query, True))
            found = [v for v in DummyAuthStore._dict.keys() if v.find(redirect_data['code']) != -1]
            assert found

            code = redirect_data.get('code')
            print r.headers


            print '------------------------------'

            # Returns:
            # code=hw87y9vtwnq7834oywv879ymo8l435sd
            # &rockpack_id=fv7j4uewhnr7rt34yklfyaiojkl

            # simulate backend calls - THIS IS NOT WHAT BROWSER SENDS
            r = client.post('/test/oauth2/token',
                    data={'code': code,
                        'grant_type': 'authorization_code',
                        'client_id': self.test_client_id,
                        'client_secret': DummyEngine.secret,
                        'redirect_uri': DummyEngine.redirect_uri})
            print r.headers
            print r.data

            # Returns:
            # {"access_token": "78435n0q2vpo934po8um4j867qnpo9l345i",
            # "refresh_token": "785vo6whkv7ym4t7g8m4n58sib546w5sye"}

            # Now that we have an access_token ...

            r = client.get('/some/resource/') # access token as bearer header
            print r.data
